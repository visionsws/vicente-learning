## 装饰者模式

简介：装饰者模式是java23种设计模式之一， 英文叫Decorator Pattern，又叫装饰者模式。 装饰模式是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。 它是通过创建一个包装对象，也就是装饰来包裹真实的对象 改变了传统继承增强对象功能所带来的弊端



### 为什么要使用装饰者模式

1个主料，多个辅料

1种主料1种辅料或者1种主料多种辅料

1种主料1种辅料的情况相当于是java中的继承，主料相当于是父类，而辅料相当于是子类，但是因为含有1种主料多种辅料的情况，新增加一种辅料的情况下，辅料之间可以相互搭配，那就相当于多了很多的子类，这种情况叫做**类爆炸**，使程序很臃肿。

这里我们看到如果使用子类继承父类，那么我们要写很多子类，这么做无疑增加了程序的臃肿性，并不是很灵活。这时，装饰者模式就诞生了。可拆卸功能，辅料之间可随时拆卸和组合



### 装饰者模式的概念及适应环境

装饰者模式又名包装模式。动态的给一个对象添加一些额外的职责。就扩展功能而言，它比生成子类的方式更为灵活。

适应场景：

以动态的方式给对象添加职责

处理那些可以撤销的职责

当采用生成子类的方法进行扩充时，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长

### 装饰者模式的结构

抽象组件(Component)：给出一个抽象接口，以规范准备接收附加责任的对象

被装饰者(ConcreteComponent):Component的具体实现，也就是我们要装饰的具体对象

装饰者组件(Decorator):持有构件(Component)对象的实例引用，该类的职责就是为了装饰具体组件对象，定义的基类

具体装饰(ConcreteDecorator):负责给构建对象装饰附加的功能

### 实例演示



### 优缺点

目的在于扩展对象的功能。装饰者模式提供比继承更好的灵活性。装饰是动态的，运动时可以修改的；继承是静态的，编译期便已确定好。



通过使用不同的装饰类及对它们的排列组合，可以创造出许多不同行为的组合

缺点：

产生很多的小对象，大量的小对象会占用内存

组合方式很多，很容易出错